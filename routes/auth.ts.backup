// server/routes/auth.ts// server/routes/auth.ts

import { Request, Response } from "express";import { Request, Response } from "express";

import express from 'express';import DatabaseConnection from '../database';

import DatabaseConnection from '../database';import bcrypt from 'bcrypt';

import bcrypt from 'bcrypt';import { notificarAdminNovoUsuario, notificarUsuarioAprovado, notificarUsuarioRejeitado } from '../email';

import jwt from 'jsonwebtoken';

import { notificarAdminNovoUsuario } from '../email';// ============================================

// HELPER: Tratamento centralizado de erros

// ============================================// ============================================

// HELPER: Tratamento centralizado de errosfunction handleDatabaseError(error: any, res: Response) {

// ============================================  if (error.message && error.message.includes('pool not initialized')) {

function handleDatabaseError(error: any, res: Response) {    return res.status(503).json({ 

  if (error.message && error.message.includes('pool not initialized')) {      success: false,

    return res.status(503).json({       message: 'Servi√ßo temporariamente indispon√≠vel. Por favor, tente novamente em alguns segundos.'

      success: false,    });

      message: 'Servi√ßo temporariamente indispon√≠vel. Por favor, tente novamente em alguns segundos.'  }

    });  console.error('Database error:', error);

  }  return res.status(500).json({ 

  console.error('Database error:', error);    success: false,

  return res.status(500).json({     message: 'Erro interno do servidor' 

    success: false,  });

    message: 'Erro interno do servidor' }

  });

}export const handleLogin = async (req: Request, res: Response) => {

  try {

// ============================================    const { email, password } = req.body;

// HANDLERS DE AUTENTICA√á√ÉO

// ============================================    console.log("üîê Tentativa de login:", { email });



export const handleLogin = async (req: Request, res: Response) => {    if (!email || !password) {

  try {      return res.status(400).json({

    const { email, password } = req.body;        success: false,

        message: "Email e senha s√£o obrigat√≥rios",

    console.log("üîê Tentativa de login:", { email });      });

    }

    if (!email || !password) {

      return res.status(400).json({    // ‚úÖ Obter pool de forma segura

        success: false,    const pool = await DatabaseConnection.getInstance();

        message: "Email e senha s√£o obrigat√≥rios",

      });    // Buscar usu√°rio nas tabelas separadas

    }    let user: any = null;

    let tipoUsuario: string = '';

    // ‚úÖ Obter pool de forma segura

    const pool = await DatabaseConnection.getInstance();    // Primeiro tentar na tabela de responsaveis

    const [responsavelRows] = await pool.execute(

    // Buscar usu√°rio nas tabelas separadas      'SELECT id, nome, login, email, senha as password, funcao, status FROM responsaveis WHERE email = ?',

    let user: any = null;      [email]

    let tipoUsuario: string = '';    );



    // Primeiro tentar na tabela de responsaveis    if ((responsavelRows as any[]).length > 0) {

    const [responsavelRows] = await pool.execute(      user = (responsavelRows as any[])[0];

      'SELECT id, nome, login, email, senha as password, funcao, status FROM responsaveis WHERE email = ?',      tipoUsuario = 'responsavel';

      [email]      

    );      // Verificar se √© admin (fun√ß√£o espec√≠fica ou email espec√≠fico)

      if (user.funcao === 'admin' || user.email === 'admin@sistema.com' || user.email === 'admin@ufla.br') {

    if ((responsavelRows as any[]).length > 0) {        user.tipo = 'admin';

      user = (responsavelRows as any[])[0];      } else {

      tipoUsuario = 'responsavel';        user.tipo = 'responsavel';

            }

      // Verificar se √© admin    } else {

      if (user.funcao === 'admin' || user.email === 'admin@sistema.com' || user.email === 'admin@ufla.br') {      // Tentar na tabela de bolsistas

        user.tipo = 'admin';      const [bolsistaRows] = await pool.execute(

      } else {        'SELECT matricula as id, nome, login, email, senha as password, curso as funcao, status FROM bolsistas WHERE email = ?',

        user.tipo = 'responsavel';        [email]

      }      );

    } else {

      // Tentar na tabela de bolsistas      if ((bolsistaRows as any[]).length > 0) {

      const [bolsistaRows] = await pool.execute(        user = (bolsistaRows as any[])[0];

        'SELECT matricula as id, nome, login, email, senha as password, curso as funcao, status FROM bolsistas WHERE email = ?',        tipoUsuario = 'bolsista';

        [email]        user.tipo = 'bolsista';

      );      }

    }

      if ((bolsistaRows as any[]).length > 0) {

        user = (bolsistaRows as any[])[0];    

        tipoUsuario = 'bolsista';    if (!user) {

        user.tipo = 'bolsista';      return res.status(404).json({

      }        success: false,

    }        message: "Usu√°rio n√£o encontrado. Verifique seu email."

      });

        }

    if (!user) {

      return res.status(404).json({    // Verificar se o usu√°rio est√° aprovado (para admins, sempre permitir)

        success: false,    if (user.tipo !== 'admin' && user.status !== 'liberado') {

        message: "Usu√°rio n√£o encontrado. Verifique seu email."      const statusMessages: { [key: string]: string } = {

      });        'pendente': 'Sua conta ainda est√° pendente de aprova√ß√£o pelo administrador.',

    }        'bloqueado': 'Sua conta foi bloqueada pelo administrador.'

      };

    // Verificar se o usu√°rio est√° aprovado (para admins, sempre permitir)      

    if (user.tipo !== 'admin' && user.status !== 'liberado') {      return res.status(403).json({

      const statusMessages: { [key: string]: string } = {        success: false,

        'pendente': 'Sua conta ainda est√° pendente de aprova√ß√£o pelo administrador.',        message: statusMessages[user.status] || 'Status da conta inv√°lido'

        'bloqueado': 'Sua conta foi bloqueada pelo administrador.'      });

      };    }

      

      return res.status(403).json({    // Verificar senha

        success: false,    const senhaCorreta = await bcrypt.compare(password, user.password);

        message: statusMessages[user.status] || 'Status da conta inv√°lido'    

      });    if (!senhaCorreta) {

    }      return res.status(401).json({

        success: false,

    // Verificar senha        message: "Senha incorreta"

    const senhaCorreta = await bcrypt.compare(password, user.password);      });

        }

    if (!senhaCorreta) {

      return res.status(401).json({    // Atualizar √∫ltimo login na tabela apropriada

        success: false,    if (tipoUsuario === 'responsavel') {

        message: "Senha incorreta"      await pool.execute(

      });        'UPDATE responsaveis SET data_atualizacao = CURRENT_TIMESTAMP WHERE id = ?',

    }        [user.id]

      );

    // Atualizar √∫ltimo login na tabela apropriada    } else if (tipoUsuario === 'bolsista') {

    if (tipoUsuario === 'responsavel') {      await pool.execute(

      await pool.execute(        'UPDATE bolsistas SET data_atualizacao = CURRENT_TIMESTAMP WHERE matricula = ?',

        'UPDATE responsaveis SET data_atualizacao = CURRENT_TIMESTAMP WHERE id = ?',        [user.id]

        [user.id]      );

      );    }

    } else if (tipoUsuario === 'bolsista') {

      await pool.execute(    // Preparar dados para enviar (sem a senha)

        'UPDATE bolsistas SET data_atualizacao = CURRENT_TIMESTAMP WHERE matricula = ?',    const { password: _, ...userWithoutPassword } = user;

        [user.id]

      );    // Gerar token simples (em produ√ß√£o use JWT)

    }    const token = Buffer.from(JSON.stringify({

      user_id: user.id,

    // Preparar dados para enviar (sem a senha)      email: user.email,

    const { password: _, ...userWithoutPassword } = user;      tipo: user.tipo,

      timestamp: Date.now()

    // Gerar token JWT    })).toString('base64');

    const token = jwt.sign(

      {     res.json({

        user_id: user.id,      success: true,

        email: user.email,      message: 'Login efetuado com sucesso',

        tipo: user.tipo,      user: userWithoutPassword,

        timestamp: Date.now()      token: token

      },    });

      process.env.JWT_SECRET || 'secret_default_key',

      { expiresIn: '24h' }  } catch (error: any) {

    );    console.error("‚ùå Erro no login:", error);

    

    return res.json({    res.status(500).json({

      success: true,      success: false,

      message: 'Login efetuado com sucesso',      message: "Erro interno do servidor"

      user: userWithoutPassword,    });

      token: token  }

    });};



  } catch (error: any) {export const handleRegister = async (req: Request, res: Response) => {

    console.error("‚ùå Erro no login:", error);  try {

    return handleDatabaseError(error, res);    const { nome, endereco, email, login, senha, tipoUsuario, funcao, matricula, curso } = req.body;

  }

};    console.log("üìù Tentativa de registro:", { email, nome, tipoUsuario });



export const handleRegister = async (req: Request, res: Response) => {    // Validar campos obrigat√≥rios

  try {    const camposObrigatorios = ['nome', 'email', 'login', 'senha', 'tipoUsuario'];

    const { nome, endereco, email, login, senha, tipoUsuario, funcao, matricula, curso } = req.body;    for (const campo of camposObrigatorios) {

      if (!req.body[campo]) {

    console.log("üìù Tentativa de registro:", { email, nome, tipoUsuario });        return res.status(400).json({

          success: false,

    // Validar campos obrigat√≥rios          message: `Campo '${campo}' √© obrigat√≥rio`

    const camposObrigatorios = ['nome', 'email', 'login', 'senha', 'tipoUsuario'];        });

    for (const campo of camposObrigatorios) {      }

      if (!req.body[campo]) {    }

        return res.status(400).json({

          success: false,    // Validar email

          message: `Campo '${campo}' √© obrigat√≥rio`    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

        });    if (!emailRegex.test(email)) {

      }      return res.status(400).json({

    }        success: false,

        message: 'Email inv√°lido'

    // Validar email      });

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;    }

    if (!emailRegex.test(email)) {

      return res.status(400).json({    // Validar senha

        success: false,    if (senha.length < 6) {

        message: 'Email inv√°lido'      return res.status(400).json({

      });        success: false,

    }        message: 'Senha deve ter pelo menos 6 caracteres'

      });

    // Validar senha    }

    if (senha.length < 6) {

      return res.status(400).json({    // Criptografar senha

        success: false,    const senhaHash = await bcrypt.hash(senha, 10);

        message: 'Senha deve ter pelo menos 6 caracteres'

      });    let novoUsuario: any;

    }    let insertResult: any;



    // ‚úÖ Obter pool de forma segura    if (tipoUsuario === 'responsavel') {

    const pool = await DatabaseConnection.getInstance();      // Valida√ß√µes espec√≠ficas para respons√°vel

      if (!funcao) {

    // Criptografar senha        return res.status(400).json({

    const senhaHash = await bcrypt.hash(senha, 10);          success: false,

          message: 'Campo fun√ß√£o √© obrigat√≥rio para respons√°veis'

    let novoUsuario: any;        });

    let insertResult: any;      }



    if (tipoUsuario === 'responsavel') {      // Verificar se email ou login j√° existem em ambas as tabelas

      // Valida√ß√µes espec√≠ficas para respons√°vel      const [responsavelEmailRows] = await pool.execute(

      if (!funcao) {        'SELECT id FROM responsaveis WHERE email = ? OR login = ?',

        return res.status(400).json({        [email, login]

          success: false,      );

          message: 'Campo fun√ß√£o √© obrigat√≥rio para respons√°veis'

        });      const [bolsistaEmailRows] = await pool.execute(

      }        'SELECT matricula FROM bolsistas WHERE email = ? OR login = ?',

        [email, login]

      // Verificar se email ou login j√° existem em ambas as tabelas      );

      const [responsavelEmailRows] = await pool.execute(

        'SELECT id FROM responsaveis WHERE email = ? OR login = ?',      if ((responsavelEmailRows as any[]).length > 0 || (bolsistaEmailRows as any[]).length > 0) {

        [email, login]        return res.status(409).json({

      );          success: false,

          message: 'Email ou login j√° cadastrados'

      const [bolsistaEmailRows] = await pool.execute(        });

        'SELECT matricula FROM bolsistas WHERE email = ? OR login = ?',      }

        [email, login]

      );      // Inserir respons√°vel

      const [result] = await pool.execute(

      if ((responsavelEmailRows as any[]).length > 0 || (bolsistaEmailRows as any[]).length > 0) {        `INSERT INTO responsaveis (nome, funcao, email, login, senha, status, data_solicitacao) 

        return res.status(409).json({         VALUES (?, ?, ?, ?, ?, 'pendente', CURRENT_TIMESTAMP)`,

          success: false,        [nome, funcao, email, login, senhaHash]

          message: 'Email ou login j√° cadastrados'      );

        });

      }      insertResult = result as any;



      // Inserir respons√°vel      // Buscar dados do respons√°vel rec√©m-criado

      const [result] = await pool.execute(      const [newUserRows] = await pool.execute(

        `INSERT INTO responsaveis (nome, funcao, email, login, senha, status, data_solicitacao)         `SELECT 

         VALUES (?, ?, ?, ?, ?, 'pendente', CURRENT_TIMESTAMP)`,          id, 

        [nome, funcao, email, login, senhaHash]          nome as nomeCompleto, 

      );          email, 

          login, 

      insertResult = result as any;          funcao,

          status,

      // Buscar dados do respons√°vel rec√©m-criado          DATE_FORMAT(data_solicitacao, '%d/%m/%Y') as dataSolicitacao,

      const [newUserRows] = await pool.execute(          'responsavel' as tipoUsuario

        `SELECT          FROM responsaveis 

          id,          WHERE id = ?`,

          nome as nomeCompleto,         [insertResult.insertId]

          email,       );

          login, 

          funcao,      novoUsuario = (newUserRows as any[])[0];

          status,

          DATE_FORMAT(data_solicitacao, '%d/%m/%Y') as dataSolicitacao,    } else if (tipoUsuario === 'bolsista') {

          'responsavel' as tipoUsuario      // Valida√ß√µes espec√≠ficas para bolsista

         FROM responsaveis       if (!matricula || !curso) {

         WHERE id = ?`,        return res.status(400).json({

        [insertResult.insertId]          success: false,

      );          message: 'Campos matr√≠cula e curso s√£o obrigat√≥rios para bolsistas'

        });

      novoUsuario = (newUserRows as any[])[0];      }



    } else if (tipoUsuario === 'bolsista') {      // Verificar se matr√≠cula, email ou login j√° existem na tabela bolsistas

      // Valida√ß√µes espec√≠ficas para bolsista      // Verificar se matr√≠cula, email ou login j√° existem em ambas as tabelas

      if (!matricula || !curso) {      const [bolsistaExistingRows] = await pool.execute(

        return res.status(400).json({        'SELECT matricula FROM bolsistas WHERE matricula = ? OR email = ? OR login = ?',

          success: false,        [matricula, email, login]

          message: 'Campos matr√≠cula e curso s√£o obrigat√≥rios para bolsistas'      );

        });

      }      const [responsavelExistingRows] = await pool.execute(

        'SELECT id FROM responsaveis WHERE email = ? OR login = ?',

      // Verificar se matr√≠cula, email ou login j√° existem em ambas as tabelas        [email, login]

      const [bolsistaExistingRows] = await pool.execute(      );

        'SELECT matricula FROM bolsistas WHERE matricula = ? OR email = ? OR login = ?',

        [matricula, email, login]      if ((bolsistaExistingRows as any[]).length > 0 || (responsavelExistingRows as any[]).length > 0) {

      );        return res.status(409).json({

          success: false,

      const [responsavelExistingRows] = await pool.execute(          message: 'Matr√≠cula, email ou login j√° cadastrados'

        'SELECT id FROM responsaveis WHERE email = ? OR login = ?',        });

        [email, login]      }

      );

      // Inserir bolsista

      if ((bolsistaExistingRows as any[]).length > 0 || (responsavelExistingRows as any[]).length > 0) {      const [result] = await pool.execute(

        return res.status(409).json({        `INSERT INTO bolsistas (matricula, nome, curso, email, login, senha, status, data_solicitacao) 

          success: false,         VALUES (?, ?, ?, ?, ?, ?, 'pendente', CURRENT_TIMESTAMP)`,

          message: 'Matr√≠cula, email ou login j√° cadastrados'        [matricula, nome, curso, email, login, senhaHash]

        });      );

      }

      // Buscar dados do bolsista rec√©m-criado

      // Inserir bolsista      const [newUserRows] = await pool.execute(

      await pool.execute(        `SELECT 

        `INSERT INTO bolsistas (matricula, nome, curso, email, login, senha, status, data_solicitacao)           matricula as id, 

         VALUES (?, ?, ?, ?, ?, ?, 'pendente', CURRENT_TIMESTAMP)`,          nome as nomeCompleto, 

        [matricula, nome, curso, email, login, senhaHash]          email, 

      );          login, 

          curso,

      // Buscar dados do bolsista rec√©m-criado          matricula,

      const [newUserRows] = await pool.execute(          status,

        `SELECT           DATE_FORMAT(data_solicitacao, '%d/%m/%Y') as dataSolicitacao,

          matricula as id,           'bolsista' as tipoUsuario

          nome as nomeCompleto,          FROM bolsistas 

          email,          WHERE matricula = ?`,

          login,         [matricula]

          curso,      );

          matricula,

          status,      novoUsuario = (newUserRows as any[])[0];

          DATE_FORMAT(data_solicitacao, '%d/%m/%Y') as dataSolicitacao,

          'bolsista' as tipoUsuario    } else {

         FROM bolsistas       return res.status(400).json({

         WHERE matricula = ?`,        success: false,

        [matricula]        message: 'Tipo de usu√°rio inv√°lido. Use "responsavel" ou "bolsista"'

      );      });

    }

      novoUsuario = (newUserRows as any[])[0];

    // Enviar email para o admin sobre a nova solicita√ß√£o

    } else {    console.log('üìß Enviando notifica√ß√£o para admin...');

      return res.status(400).json({    const emailResult = await notificarAdminNovoUsuario({

        success: false,      nome: nome,

        message: 'Tipo de usu√°rio inv√°lido. Use "responsavel" ou "bolsista"'      email: email,

      });      login: login,

    }      endereco: endereco || ''

    });

    // Enviar email para o admin sobre a nova solicita√ß√£o

    console.log('üìß Enviando notifica√ß√£o para admin...');    if (emailResult.success) {

    const emailResult = await notificarAdminNovoUsuario({      console.log('‚úÖ Email enviado para admin com sucesso');

      nome: nome,    } else {

      email: email,      console.log('‚ö†Ô∏è Falha ao enviar email para admin:', emailResult.error);

      login: login,    }

      endereco: endereco || ''

    });    res.json({

      success: true,

    if (emailResult.success) {      message: `${tipoUsuario === 'responsavel' ? 'Respons√°vel' : 'Bolsista'} registrado com sucesso! Aguarde a aprova√ß√£o do administrador.`,

      console.log('‚úÖ Email enviado para admin com sucesso');      data: novoUsuario

    } else {    });

      console.log('‚ö†Ô∏è Falha ao enviar email para admin:', emailResult.error);

    }  } catch (error: any) {

    console.error("‚ùå Erro no registro:", error);

    return res.json({    

      success: true,    res.status(500).json({

      message: `${tipoUsuario === 'responsavel' ? 'Respons√°vel' : 'Bolsista'} registrado com sucesso! Aguarde a aprova√ß√£o do administrador.`,      success: false,

      data: novoUsuario      message: "Erro interno do servidor"

    });    });

  }

  } catch (error: any) {};

    console.error("‚ùå Erro no registro:", error);

    return handleDatabaseError(error, res);import express from 'express';

  }import { db } from '../database';

};import jwt from 'jsonwebtoken';

import { sendEmail } from '../email';

// ============================================

// ROUTER EXPRESSconst router = express.Router();

// ============================================

// Rota para registro de usu√°rios

const router = express.Router();router.post('/register', async (req, res) => {

  try {

// Rota para verificar status do backend    const { nome, email, senha, tipo = 'usuario' } = req.body;

router.get('/status', (_req, res) => {    

  res.json({    // Valida√ß√£o b√°sica

    success: true,    if (!nome || !email || !senha) {

    message: 'API funcionando normalmente',      return res.status(400).json({ 

    timestamp: new Date().toISOString()        success: false, 

  });        message: 'Dados incompletos para cadastro' 

});      });

    }

export default router;    

    // Verificar se o email j√° existe
    const [existingUsers] = await db.execute(
      'SELECT * FROM usuarios WHERE email = ?',
      [email]
    );
    
    if (Array.isArray(existingUsers) && existingUsers.length > 0) {
      return res.status(409).json({ 
        success: false, 
        message: 'Este email j√° est√° cadastrado' 
      });
    }
    
    // Hash da senha
    const hashedPassword = await bcrypt.hash(senha, 10);
    
    // Inserir usu√°rio como pendente
    const [result] = await db.execute(
      'INSERT INTO usuarios (nome, email, senha, tipo, status, data_solicitacao) VALUES (?, ?, ?, ?, ?, NOW())',
      [nome, email, hashedPassword, tipo, 'pendente']
    );
    
    // Obter o ID inserido
    const userId = (result as any).insertId;
    
    // Enviar notifica√ß√£o para admin (opcional)
    try {
      await sendEmail({
        to: 'admin@example.com', // Email do administrador
        subject: 'Nova solicita√ß√£o de acesso',
        text: `O usu√°rio ${nome} (${email}) solicitou acesso ao sistema. Acesse o painel de administra√ß√£o para aprovar ou rejeitar.`,
      });
      console.log('‚úâÔ∏è Email de notifica√ß√£o enviado ao admin');
    } catch (emailError) {
      console.error('Erro ao enviar email de notifica√ß√£o:', emailError);
      // N√£o interrompe o fluxo se o email falhar
    }
    
    console.log(`üë§ Novo usu√°rio registrado com ID ${userId} e status 'pendente'`);
    
    res.status(201).json({
      success: true,
      message: 'Solicita√ß√£o de acesso enviada com sucesso. Aguarde aprova√ß√£o.',
      userId
    });
    
  } catch (error) {
    console.error('Erro no registro:', error);
    res.status(500).json({
      success: false,
      message: 'Erro ao processar solicita√ß√£o de acesso',
      error: (error as Error).message
    });
  }
});

// Rota para login
router.post('/login', async (req, res) => {
  try {
    const { email, senha } = req.body;
    
    // Valida√ß√£o b√°sica
    if (!email || !senha) {
      return res.status(400).json({ 
        success: false, 
        message: 'Email e senha s√£o obrigat√≥rios' 
      });
    }
    
    // Buscar usu√°rio pelo email
    const [users] = await db.execute(
      'SELECT * FROM usuarios WHERE email = ?',
      [email]
    );
    
    const user = Array.isArray(users) && users.length > 0 ? users[0] : null;
    
    if (!user) {
      return res.status(401).json({ 
        success: false, 
        message: 'Credenciais inv√°lidas' 
      });
    }
    
    // Verificar status do usu√°rio
    if (user.status === 'pendente') {
      return res.status(403).json({
        success: false,
        message: 'Sua conta est√° aguardando aprova√ß√£o por um administrador'
      });
    }
    
    if (user.status === 'bloqueado') {
      return res.status(403).json({
        success: false,
        message: 'Sua conta est√° bloqueada. Entre em contato com o administrador.'
      });
    }
    
    // Verificar senha
    const passwordMatch = await bcrypt.compare(senha, user.senha);
    
    if (!passwordMatch) {
      return res.status(401).json({ 
        success: false, 
        message: 'Credenciais inv√°lidas' 
      });
    }
    
    // Gerar token JWT
    const token = jwt.sign(
      { 
        userId: user.id, 
        email: user.email,
        tipo: user.tipo
      },
      process.env.JWT_SECRET || 'secret_default_key', // Use uma vari√°vel de ambiente real
      { expiresIn: '24h' }
    );
    
    console.log(`üîì Login bem-sucedido: ${user.email} (${user.tipo})`);
    
    // Remover senha antes de enviar resposta
    const { senha: _, ...userWithoutPassword } = user;
    
    res.json({
      success: true,
      message: 'Login realizado com sucesso',
      token,
      user: userWithoutPassword
    });
    
  } catch (error) {
    console.error('Erro no login:', error);
    res.status(500).json({
      success: false,
      message: 'Erro ao processar login',
      error: (error as Error).message
    });
  }
});

// Rota para listar todos os usu√°rios (para o painel admin)
router.get('/usuarios', async (req, res) => {
  try {
    // Em produ√ß√£o, adicione verifica√ß√£o de permiss√£o aqui
    
    // Buscar todos os usu√°rios
    const [users] = await db.execute(
      'SELECT id, nome, email, tipo, status, data_solicitacao FROM usuarios ORDER BY data_solicitacao DESC'
    );
    
    console.log(`üìã Listando ${Array.isArray(users) ? users.length : 0} usu√°rios`);
    
    res.json({
      success: true,
      data: users
    });
    
  } catch (error) {
    console.error('Erro ao listar usu√°rios:', error);
    res.status(500).json({
      success: false,
      message: 'Erro ao listar usu√°rios',
      error: (error as Error).message
    });
  }
});

// Rota para aprovar um usu√°rio
router.put('/usuarios/:id/aprovar', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Verificar se o usu√°rio existe
    const [users] = await db.execute(
      'SELECT * FROM usuarios WHERE id = ?',
      [id]
    );
    
    if (!Array.isArray(users) || users.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Usu√°rio n√£o encontrado'
      });
    }
    
    // Atualizar status para "liberado"
    await db.execute(
      'UPDATE usuarios SET status = ? WHERE id = ?',
      ['liberado', id]
    );
    
    const user = users[0];
    
    // Enviar email de notifica√ß√£o ao usu√°rio
    try {
      await sendEmail({
        to: user.email,
        subject: 'Acesso Aprovado',
        text: `Ol√° ${user.nome}, sua solicita√ß√£o de acesso foi aprovada. Voc√™ j√° pode fazer login no sistema.`,
      });
      console.log(`‚úâÔ∏è Email de aprova√ß√£o enviado para ${user.email}`);
    } catch (emailError) {
      console.error('Erro ao enviar email de aprova√ß√£o:', emailError);
      // N√£o interrompe o fluxo se o email falhar
    }
    
    console.log(`‚úÖ Usu√°rio ${id} aprovado com sucesso`);
    
    res.json({
      success: true,
      message: 'Usu√°rio aprovado com sucesso'
    });
    
  } catch (error) {
    console.error('Erro ao aprovar usu√°rio:', error);
    res.status(500).json({
      success: false,
      message: 'Erro ao aprovar usu√°rio',
      error: (error as Error).message
    });
  }
});

// Rota para rejeitar/bloquear um usu√°rio
router.put('/usuarios/:id/rejeitar', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Verificar se o usu√°rio existe
    const [users] = await db.execute(
      'SELECT * FROM usuarios WHERE id = ?',
      [id]
    );
    
    if (!Array.isArray(users) || users.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Usu√°rio n√£o encontrado'
      });
    }
    
    // Atualizar status para "bloqueado"
    await db.execute(
      'UPDATE usuarios SET status = ? WHERE id = ?',
      ['bloqueado', id]
    );
    
    const user = users[0];
    
    // Enviar email de notifica√ß√£o ao usu√°rio
    try {
      await sendEmail({
        to: user.email,
        subject: 'Acesso Bloqueado',
        text: `Ol√° ${user.nome}, sua solicita√ß√£o de acesso foi rejeitada ou sua conta foi bloqueada. Entre em contato com o administrador para mais informa√ß√µes.`,
      });
      console.log(`‚úâÔ∏è Email de rejei√ß√£o enviado para ${user.email}`);
    } catch (emailError) {
      console.error('Erro ao enviar email de rejei√ß√£o:', emailError);
      // N√£o interrompe o fluxo se o email falhar
    }
    
    console.log(`üö´ Usu√°rio ${id} bloqueado com sucesso`);
    
    res.json({
      success: true,
      message: 'Usu√°rio bloqueado com sucesso'
    });
    
  } catch (error) {
    console.error('Erro ao bloquear usu√°rio:', error);
    res.status(500).json({
      success: false,
      message: 'Erro ao bloquear usu√°rio',
      error: (error as Error).message
    });
  }
});

// Rota para verificar status do backend
router.get('/status', (req, res) => {
  res.json({
    success: true,
    message: 'API funcionando normalmente',
    timestamp: new Date().toISOString()
  });
});

export default router;

